# Анализ результатов работы статического анализатора кода

Проанализировать результаты работы статического анализатора. Для каждого из срабатываний необходимо определить корректность. Для подтверждённых срабатываний привести описание возникающих проблем и возможных последствий. Для срабатываний, определённых как ложные, объяснить решение о их невалидности. 
При проведении реальных испытаний, лаборатория имеет больше информации, чем представлено в тесте (частные случаи реализации, процессорная архитектура, версия компилятора/среды выполнения и т.д.). В случае, если специалисты испытательной лаборатории считают, что для точного определения верности/ложности срабатывания информации недостаточно, допускается описать варианты, при которых следует валидировать срабатывание как ложноположительное, а при каких как верноположительное.

Следует считать, что непредставленный код не влияет на возможность возникновения уязвимости в представленном фрагменте.
Непредставленный код заменяется на строку «//произвольный код».
Все переменные, функции, методы и классы задекларированы, а названия соответствуют функциональному назначению.

## C/C++
## 1. Контекст обнаружения
Статический анализатор сообщает:
"Unreachable code / Always false condition: logical expression is always false"
Код:
```cpp
int number = GetValueFromHardware();
if (number > 0xFFFFFFFF) {
    //произвольный код
}
```
### 1.1. Семантический анализ
#### 1.1.1. Диапазон типа int
На 99% современных платформ (ILP32, LLP64, LP64):
```cpp
int -> 32-битный знаковый тип
Диапазон: -2147483648 … 2147483647
```
#### 1.1.2. Тип литерала 0xFFFFFFFF
По правилам C/C++:
- шестнадцатеричный целочисленный литерал не имеет знака по умолчанию.
- компилятор назначает минимальный тип, способный вместить значение.
- значение `0xFFFFFFFF (4294967295)` не влезает в `int`, поэтому тип литерала -> `unsigned int` или `unsigned long` (платформозависимо).
#### 1.1.3. Логика сравнения
Левая часть: `int` -> знаковый.
Правая часть: `unsigned` -> беззнаковый.
Знаковое число приводится к беззнаковому перед сравнением.
Это означает:
```cpp
int number = ANY (>=0 or <0);
-> преобразуется к unsigned int перед сравнением
unsigned representation of negative values -> huge positive values
```

Однако этот факт не меняет итог: условие никогда не будет истинным, т.к.:
- максимальное `unsigned`-представление преобразованного `int` не превышает `UINT_MAX`,
- литерал — `4294967295`, что и есть `UINT_MAX` (для платформ, где `unsigned int` = 32 бита).
Таким образом, на любых корректных данных `int` невозможно получить значение больше `0xFFFFFFFF`.

### 1.2. Подтверждение: демонстрация средствами Semgrep
Покажем, как Semgrep может обнаружить подобную ошибку. Создадим правила Semgrep:
`semgrep-rule.yaml`
```yaml
rules:
  - id: always-false-condition-large-constant
    message: "The condition appears always false: signed int compared to a too-large constant"
    severity: WARNING
    languages: [c, cpp]
    patterns:
      - pattern: |
          if ($X > 0xFFFFFFFF) {
            ...
          }
    metadata:
      likelihood: HIGH
      impact: MEDIUM
      confidence: HIGH
```
Теперь создаём тестовый файл:
```cpp
int GetValueFromHardware();

int main() {
    int number = GetValueFromHardware();
    if (number > 0xFFFFFFFF) {
        return 1;
    }
    return 0;
}
```

Запуск анализа:
```bash
semgrep --config semgrep-rule.yaml test.c
```

Результат:
```bash
test.c:5:5 warning always-false-condition-large-constant
The condition appears always false: signed int compared to a too-large constant
```

Semgrep указывает на:
- провал типа (`int` vs очень большой литерал);
- логическую ошибку;
- недостижимый код.

### 1.3. Корректность срабатывания статанализа
В большинстве реальных условий срабатывание корректно (верноположительное, TP)
Причины:
1. Значение `0xFFFFFFFF` недостижимо для переменной типа `int`
2. Условие никогда не будет истинным
3. Блок кода внутри if недостижим
4. Это логическая ошибка, потенциально влияющая на безопасность (ошибочные ветви обработки ошибок/критических данных)

### 1.4. Возможные последствия
Логическая ошибка. 
1. Пропуск ветки обработки ошибок, которая считалась автором кода работающей.
2. Недостижимый фрагмент может скрывать потенциальный функционал, который должен был реагировать на сбой оборудования.
3. В условиях безопасности — это может приводить к:
- пропуску контроля целостности,
- неправильной реакций на "аномальные" сигналы устройства.

Ошибка проектирования. 
1. Разработчик ожидал, что аппаратное значение может быть выше UINT_MAX, что неверно.
2. Некорректное понимание диапазонов и преобразований типов.

### 1.5. Когда можно признать срабатывание ложноположительным?
Испытательная лаборатория обычно делает такие допуски.
Ложноположительное (FP) возможно, если:
1. В архитектуре размер `int >= 33–64 бит` (не встречается в промышленных ABI, но теоретически возможно).
2. `0xFFFFFFFF` трактуется как 32-битный NEGATIVE `signed literal` (нарушение стандартов, но встречается в нестандартных компиляторах для DSP/embedded).
3. `GetValueFromHardware()` имеет нестандартную ABI,
например, возвращает 64-битное значение, а разработчик ошибочно объявил int.
Но даже в таких случаях проблема скорее в объявлении `int`.

### 1.6. Итоговая оценка
Вердикт: срабатывание валидное (верноположительное).
Причина:
- условие сравнивает 32-битное знаковое число с 4,29 млрд;
- сравнение всегда ложно;
- ветка кода недостижима;
- это нарушение логики программы.